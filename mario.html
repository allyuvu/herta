<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Retro Kart Mode 7</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; background: #222; overflow: hidden; 
            font-family: 'Courier New', monospace;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }

        /* The Game Console Look */
        #console-frame {
            width: 800px; height: 600px;
            background: #000;
            position: relative;
            border: 10px solid #444;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden;
        }

        /* The Sky (Parallax) */
        #sky {
            position: absolute; top: 0; left: 0; width: 100%; height: 50%;
            background: linear-gradient(to bottom, #00bfff 0%, #87cefa 100%);
            z-index: 1;
        }
        #clouds {
            position: absolute; top: 20px; left: 0; width: 200%; height: 100px;
            background: repeating-linear-gradient(90deg, transparent 0, transparent 50px, rgba(255,255,255,0.4) 50px, rgba(255,255,255,0.4) 100px);
            animation: drift 20s linear infinite;
        }
        @keyframes drift { from {transform: translateX(0);} to {transform: translateX(-50%);} }

        /* The Mode 7 Perspective Container */
        #mode7-container {
            position: absolute;
            top: 50%; left: 0; width: 100%; height: 50%;
            perspective: 600px; /* The Magic 3D Depth */
            z-index: 2;
            overflow: hidden;
        }

        /* The Track Canvas - Tilted */
        #track-layer {
            position: absolute;
            left: -50%; top: -50%;
            width: 200%; height: 200%;
            transform-origin: center center;
            transform: rotateX(60deg); /* Retro Tilt */
            image-rendering: pixelated;
        }

        /* UI Layer (HUD) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top { display: flex; justify-content: space-between; padding: 20px; }
        .hud-text { font-size: 24px; color: #fff; text-shadow: 2px 2px 0 #000; font-weight: bold; font-family: sans-serif; }
        
        #item-box {
            width: 60px; height: 60px; border: 4px solid #fff; background: rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center; font-size: 30px;
        }

        #lap-time { color: #ffff00; }

        /* Start Signal */
        #center-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 80px; color: #fff; text-shadow: 5px 5px 0 #000, 0 0 20px red;
            font-weight: 900; z-index: 20; display: none;
        }

    </style>
</head>
<body>

<div id="console-frame">
    <div id="sky"><div id="clouds"></div></div>
    
    <div id="mode7-container">
        <canvas id="track-layer"></canvas>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="item-box"></div>
            <div class="hud-text">LAP <span id="lap-count">1</span>/3</div>
            <div class="hud-text" id="lap-time">00:00</div>
        </div>
    </div>

    <div id="center-msg">3</div>
</div>

<script>
/**
 * RETRO RACING ENGINE
 * Simulates Mode 7 by rotating a 2D canvas that is CSS-transformed.
 */

// --- Assets & Configuration ---
const CONFIG = {
    canvasSize: 2048, // Giant map
    renderSize: 1000, // Viewport on canvas
    maxSpeed: 12,
    turnSpeed: 0.07,
    friction: 0.96,
    accel: 0.2,
    grassSpeed: 3
};

const COLORS = {
    grass: '#3da834',
    road: '#555555',
    line: '#ffffff',
    border: '#d63636',
    sand: '#d2b48c'
};

// --- Game State ---
const state = {
    player: { x: 1000, y: 1800, angle: -Math.PI/2, speed: 0, item: null },
    ai: { x: 950, y: 1800, angle: -Math.PI/2, speed: 0, waypoint: 0 },
    camera: { x: 0, y: 0, angle: 0 },
    keys: { up: false, down: false, left: false, right: false, space: false },
    trackData: null, // Will hold pixel data for collision
    items: [], // Boxes on track
    hazards: [], // Bananas
    lap: 1,
    time: 0,
    started: false,
    frame: 0
};

// --- Initialization ---
const canvas = document.getElementById('track-layer');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
canvas.width = CONFIG.canvasSize;
canvas.height = CONFIG.canvasSize;

// Pre-render the track
const trackCanvas = document.createElement('canvas');
trackCanvas.width = CONFIG.canvasSize;
trackCanvas.height = CONFIG.canvasSize;
const tCtx = trackCanvas.getContext('2d');

// Define Track Path (Waypoints)
const waypoints = [
    {x:1000, y:1800}, {x:1000, y:1400}, {x:1200, y:1100}, {x:1600, y:1100}, 
    {x:1800, y:800}, {x:1600, y:400}, {x:1000, y:200}, {x:400, y:400}, 
    {x:200, y:800}, {x:400, y:1200}, {x:800, y:1400}, {x:800, y:1700}
];

function drawTrack() {
    // 1. Grass Base
    tCtx.fillStyle = COLORS.grass;
    tCtx.fillRect(0,0, CONFIG.canvasSize, CONFIG.canvasSize);

    // 2. Draw Road
    tCtx.lineCap = 'round';
    tCtx.lineJoin = 'round';
    
    // Border
    tCtx.lineWidth = 260;
    tCtx.strokeStyle = COLORS.sand;
    drawPath(tCtx, true);

    // Rumble Strips
    tCtx.lineWidth = 240;
    tCtx.strokeStyle = COLORS.border;
    drawPath(tCtx, true);

    // Asphalt
    tCtx.lineWidth = 220;
    tCtx.strokeStyle = COLORS.road;
    drawPath(tCtx, true);

    // Start Line
    tCtx.save();
    tCtx.translate(1000, 1750);
    tCtx.fillStyle = '#fff';
    tCtx.fillRect(-110, 0, 220, 20);
    
    // Checkered pattern
    tCtx.fillStyle = '#000';
    for(let i=0; i<10; i++) {
        tCtx.fillRect(-110 + i*22, 0, 11, 10);
        tCtx.fillRect(-110 + i*22 + 11, 10, 11, 10);
    }
    tCtx.restore();

    // 3. Decorations (Trees)
    for(let i=0; i<50; i++) {
        let tx = Math.random() * CONFIG.canvasSize;
        let ty = Math.random() * CONFIG.canvasSize;
        // Simple tree blob
        tCtx.fillStyle = '#1e5919';
        tCtx.beginPath(); tCtx.arc(tx, ty, 30, 0, Math.PI*2); tCtx.fill();
        tCtx.fillStyle = '#2d8a25';
        tCtx.beginPath(); tCtx.arc(tx-10, ty-10, 20, 0, Math.PI*2); tCtx.fill();
    }

    // Generate Collision Map
    state.trackData = tCtx.getImageData(0,0, CONFIG.canvasSize, CONFIG.canvasSize).data;

    // Place Item Boxes
    state.items.push({x: 1000, y: 1300, active: true});
    state.items.push({x: 1200, y: 1300, active: true});
    state.items.push({x: 800, y: 1300, active: true});
}

function drawPath(c, stroke) {
    c.beginPath();
    c.moveTo(waypoints[0].x, waypoints[0].y);
    for(let i=1; i<waypoints.length; i++) c.lineTo(waypoints[i].x, waypoints[i].y);
    c.closePath();
    if(stroke) c.stroke();
}

// --- Logic ---

function checkCollision(obj) {
    // Boundary check
    if(obj.x < 0 || obj.x > CONFIG.canvasSize || obj.y < 0 || obj.y > CONFIG.canvasSize) {
        obj.speed *= -0.5;
        return 'grass';
    }

    // Color check (Road vs Grass)
    const px = Math.floor(obj.x);
    const py = Math.floor(obj.y);
    const idx = (py * CONFIG.canvasSize + px) * 4;
    
    const r = state.trackData[idx];
    const g = state.trackData[idx+1];
    const b = state.trackData[idx+2];

    // Road is Grey (#555555 -> 85,85,85) or Start line
    // Grass is Greenish
    const isRoad = (r === 85 && g === 85 && b === 85) || (r > 200 && g > 200 && b > 200) || (r===0 && g===0 && b===0);
    
    return isRoad ? 'road' : 'grass';
}

function updatePlayer() {
    const p = state.player;

    // Input Steer
    if(state.keys.left) p.angle -= CONFIG.turnSpeed;
    if(state.keys.right) p.angle += CONFIG.turnSpeed;

    // Accelerate
    if(state.keys.up) p.speed += CONFIG.accel;
    else if(state.keys.down) p.speed -= CONFIG.accel;
    else p.speed *= CONFIG.friction; // Coasting

    // Physics checks
    const terrain = checkCollision(p);
    let cap = CONFIG.maxSpeed;
    if(terrain === 'grass') cap = CONFIG.grassSpeed;

    if(p.speed > cap) p.speed = Math.max(cap, p.speed * 0.9); // Decelerate if on grass
    if(p.speed < -4) p.speed = -4; // Reverse cap

    // Move
    p.x += Math.cos(p.angle) * p.speed;
    p.y += Math.sin(p.angle) * p.speed;

    // Item Usage
    if(state.keys.space && p.item) {
        useItem(p.item);
        p.item = null;
        updateItemUI();
    }
}

function updateAI() {
    if(!state.started) return;
    const ai = state.ai;
    const target = waypoints[ai.waypoint];
    
    // Angle to target
    const dx = target.x - ai.x;
    const dy = target.y - ai.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const targetAngle = Math.atan2(dy, dx);
    
    // Smooth turn
    let diff = targetAngle - ai.angle;
    while(diff < -Math.PI) diff += Math.PI*2;
    while(diff > Math.PI) diff -= Math.PI*2;
    
    ai.angle += diff * 0.1;
    
    // Speed (AI cheats: constant speed mostly)
    ai.speed = 10.5;
    
    // Check Hazards
    state.hazards.forEach(h => {
        const hdx = h.x - ai.x;
        const hdy = h.y - ai.y;
        if(Math.sqrt(hdx*hdx + hdy*hdy) < 30) {
            ai.speed = 0; // Spin out
        }
    });

    ai.x += Math.cos(ai.angle) * ai.speed;
    ai.y += Math.sin(ai.angle) * ai.speed;

    // Next waypoint
    if(dist < 100) {
        ai.waypoint = (ai.waypoint + 1) % waypoints.length;
    }
}

function checkItems() {
    // Check Boxes
    state.items.forEach(box => {
        if(!box.active) return;
        const dx = state.player.x - box.x;
        const dy = state.player.y - box.y;
        if(Math.sqrt(dx*dx + dy*dy) < 30) {
            box.active = false;
            rollItem();
            setTimeout(() => box.active = true, 5000); // Respawn
        }
    });

    // Check Bananas
    state.hazards.forEach((h, i) => {
        const dx = state.player.x - h.x;
        const dy = state.player.y - h.y;
        if(Math.sqrt(dx*dx + dy*dy) < 20) {
            state.player.speed = 0; // Spin
            state.hazards.splice(i, 1);
            // Visual spin effect could be added here
        }
    });
}

function rollItem() {
    const items = ['ðŸ„', 'ðŸŒ']; 
    // Animation
    let count = 0;
    const box = document.getElementById('item-box');
    const interval = setInterval(() => {
        box.innerText = items[count % items.length];
        count++;
        if(count > 10) {
            clearInterval(interval);
            state.player.item = Math.random() > 0.5 ? 'mushroom' : 'banana';
            box.innerText = state.player.item === 'mushroom' ? 'ðŸ„' : 'ðŸŒ';
        }
    }, 100);
}

function useItem(type) {
    if(type === 'mushroom') {
        state.player.speed = 20; // Turbo
    } else if (type === 'banana') {
        // Place behind player
        state.hazards.push({
            x: state.player.x - Math.cos(state.player.angle)*40,
            y: state.player.y - Math.sin(state.player.angle)*40
        });
        document.getElementById('item-box').innerText = "";
    }
}

function updateItemUI() {
    if(!state.player.item) document.getElementById('item-box').innerText = "";
}

// --- Render ---

function render() {
    // 1. Clear Canvas
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // 2. Camera Transform Logic
    // We want the player to be at the bottom center of the screen
    // The canvas is rotated so that "Up" is where the player is facing
    const camX = state.player.x;
    const camY = state.player.y;
    const camRot = state.player.angle + Math.PI/2;

    // Apply translation to draw the map correctly relative to player
    // Note: We are drawing the WHOLE map every frame, but rotating it.
    
    ctx.save();
    
    // Move origin to center of viewport
    const cx = canvas.width / 2;
    const cy = canvas.height / 2 + 200; // Move horizon up/down

    ctx.translate(cx, cy);
    ctx.rotate(-camRot);
    ctx.translate(-camX, -camY);

    // Draw Static Map
    ctx.drawImage(trackCanvas, 0, 0);

    // Draw Items
    state.items.forEach(box => {
        if(box.active) {
            ctx.fillStyle = '#f8d210';
            ctx.fillRect(box.x-15, box.y-15, 30, 30);
            ctx.fillStyle = '#000';
            ctx.font = '20px sans-serif';
            ctx.fillText('?', box.x-5, box.y+7);
        }
    });

    // Draw Hazards
    state.hazards.forEach(h => {
        ctx.font = '30px serif';
        ctx.fillText('ðŸŒ', h.x-10, h.y+10);
    });

    // Draw AI Kart
    ctx.save();
    ctx.translate(state.ai.x, state.ai.y);
    ctx.rotate(state.ai.angle);
    drawKart(ctx, 'green');
    ctx.restore();

    ctx.restore(); // Undo map rotation

    // 3. Draw Player (Fixed at center)
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2 + 200);
    // Player is always facing UP relative to screen in Mode 7
    ctx.rotate(-Math.PI/2); 
    drawKart(ctx, 'red');
    ctx.restore();
}

function drawKart(c, color) {
    // Simple pixel kart
    c.fillStyle = '#000'; // Shadow
    c.fillRect(-18, -18, 36, 36);
    
    c.fillStyle = color; // Body
    c.fillRect(-15, -15, 30, 30);
    
    c.fillStyle = '#eee'; // Driver Head
    c.fillRect(-5, -5, 10, 10);
    
    // Wheels
    c.fillStyle = '#222';
    c.fillRect(10, 10, 12, 6);
    c.fillRect(10, -16, 12, 6);
    c.fillRect(-22, 10, 12, 6);
    c.fillRect(-22, -16, 12, 6);
}

// --- Loop & Controls ---

function loop() {
    if(state.started) {
        updatePlayer();
        updateAI();
        checkItems();
        
        // Lap Logic (Simple y-crossing check)
        // If passed start line Y and close to center X
        if(state.player.y > 1750 && state.player.y < 1780 && state.player.x > 900 && state.player.x < 1100) {
            // Need a cooldown or direction check for real laps, simpler here:
             // Assume valid lap if enough time passed
             if(Date.now() - state.time > 10000) {
                 // Lap logic simplified
             }
        }
    }
    
    render();
    requestAnimationFrame(loop);
}

window.addEventListener('keydown', e => {
    if(e.key === 'ArrowUp' || e.key === 'w') state.keys.up = true;
    if(e.key === 'ArrowDown' || e.key === 's') state.keys.down = true;
    if(e.key === 'ArrowLeft' || e.key === 'a') state.keys.left = true;
    if(e.key === 'ArrowRight' || e.key === 'd') state.keys.right = true;
    if(e.key === ' ') state.keys.space = true;
});

window.addEventListener('keyup', e => {
    if(e.key === 'ArrowUp' || e.key === 'w') state.keys.up = false;
    if(e.key === 'ArrowDown' || e.key === 's') state.keys.down = false;
    if(e.key === 'ArrowLeft' || e.key === 'a') state.keys.left = false;
    if(e.key === 'ArrowRight' || e.key === 'd') state.keys.right = false;
    if(e.key === ' ') state.keys.space = false;
});

// Start Sequence
drawTrack();
const msg = document.getElementById('center-msg');
msg.style.display = 'block';

let count = 3;
const timer = setInterval(() => {
    if(count > 0) {
        msg.innerText = count;
        msg.style.color = count === 1 ? 'red' : '#fff';
    } else if (count === 0) {
        msg.innerText = "GO!";
        msg.style.color = '#00ff00';
        state.started = true;
        state.time = Date.now();
    } else {
        msg.style.display = 'none';
        clearInterval(timer);
    }
    count--;
}, 1000);

loop();

</script>
</body>
</html>